{"ts":1367457648258,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/* global window:true, Ext:true */\n\n(function() {\n\n    Ext.define('Ext.oj-sqlbuilder.SQLFieldsGrid', {\n        requires: ['Ext.ux.CheckColumn'],\n        extend: 'Ext.grid.Panel',\n        alias: ['widget.sqlfieldsgrid'],\n        id: 'SQLFieldsGrid',\n        store: 'SQLFieldsStore',\n        columnLines: true,\n        plugins: [Ext.create('Ext.grid.plugin.CellEditing', {\n            clicksToEdit: 1\n        })],\n        viewConfig: {\n            listeners: {\n                render: function(view) {\n                    this.dd = {};\n                    this.dd.dropZone = new Ext.grid.ViewDropZone({\n                        view: view,\n                        ddGroup: 'SQLTableGridDDGroup',\n                        handleNodeDrop: function(data, record, position) {\n                            // Was soll nach dem Drop passieren?\n                        }\n                    });\n                },\n                drop: function(node, data, dropRec, dropPosition) {\n                    // add new rows to the SQLFieldsGrid after a drop\n                    for (var i = 0, l = data.records.length; i < l; i++) {\n                        oj.sql.builder.sqlSelect.addFieldRecord(data.records[i], false);\n                    }\n                }\n            }\n        },\n        columns: [{\n            xtype: 'actioncolumn',\n            menuDisabled: true,\n            text: 'Action',\n            width: 60,\n            moveGridRow: function(grid, record, index, direction) {\n                var store = grid.getStore();\n                if (direction < 0) {\n                    index--;\n                    if (index < 0) {\n                        return;\n                    }\n                }\n                else {\n                    index++;\n                    if (index >= grid.getStore().getCount()) {\n                        return;\n                    }\n                }\n                // prepare manual syncing\n                store.suspendAutoSync();\n                // disable firing store events\n                store.suspendEvents();\n                // remove record and insert record at new index\n                store.remove(record);\n                store.insert(index, record);\n                // enable firing store events\n                store.resumeEvents();\n                store.resumeAutoSync();\n                // manual sync the store\n                store.sync();\n            },\n            items: [{\n                icon: 'resources/images/up_arrow.gif',\n                tooltip: 'Move Column Up',\n                getClass: function(value, metadata, record) {\n                    var store, index;\n                    store = record.store;\n                    index = store.indexOf(record);\n                    if (index == 0) {\n                        return 'x-action-icon-disabled';\n                    }\n                    else {\n                        return 'x-grid-center-icon';\n                    }\n                },\n                handler: function(grid, rowIndex, colIndex) {\n                    var rec = grid.getStore().getAt(rowIndex);\n                    this.moveGridRow(grid, rec, rowIndex, - 1);\n                }\n            }, {\n                icon: 'resources/images/down_arrow.gif',\n                getClass: function(value, metadata, record) {\n                    var store, index;\n                    store = record.store;\n                    index = store.indexOf(record);\n                    if ((index + 1) == store.getCount()) {\n                        return 'x-action-icon-disabled';\n                    }\n                    else {\n                        return 'x-grid-center-icon';\n                    }\n                },\n                tooltip: 'Move Column Down',\n                handler: function(grid, rowIndex, colIndex) {\n                    var rec = grid.getStore().getAt(rowIndex);\n                    this.moveGridRow(grid, rec, rowIndex, 1);\n                }\n            }, {\n                icon: 'resources/images/remove.gif',\n                iconCls: 'x-grid-center-icon',\n                tooltip: 'Delete Column',\n                handler: function(grid, rowIndex, colIndex) {\n                    var rec = grid.getStore().getAt(rowIndex),\n                        store, tableId, tableGrid, selectionModel, bDel = true;\n                    // rec contains column grid model, the one to remove\n                    // get tableId of original sqltable\n                    tableId = rec.get('extCmpId');\n                    // get the sql tables grid and its selection\n                    tableGrid = Ext.getCmp(tableId).down('gridpanel');\n                    selectionModel = tableGrid.getSelectionModel();\n                    Ext.Array.each(selectionModel.getSelection(), function(selection) {\n                        // deselect the selection wich corresponds to the column\n                        // we want to remove from the column grid\n                        if (rec.get('id') == selection.get('id')) {\n                            // deselect current selection\n                            // deselection will lead to removal, look for method deselect at the SQLTableGrid\n                            selectionModel.deselect(selection);\n                            bDel = false;\n                        }\n                    });\n                    if (bDel) {\n                        store = grid.getStore();\n                        store.remove(rec);\n                    }\n                }\n            }]\n        }, {\n            xtype: 'checkcolumn',\n            sortable: false,\n            text: 'Output',\n            flex: 0.075,\n            menuDisabled: true,\n            dataIndex: 'output',\n            align: 'center'\n        }, {\n            xtype: 'gridcolumn',\n            text: 'Expression',\n            sortable: false,\n            menuDisabled: true,\n            flex: 0.225,\n            dataIndex: 'expression',\n            editor: 'textfield'\n        }, {\n            xtype: 'gridcolumn',\n            text: 'Aggregate',\n            flex: 0.125,\n            sortable: false,\n            menuDisabled: true,\n            dataIndex: 'aggregate',\n            editor: 'textfield'\n        }, {\n            xtype: 'gridcolumn',\n            text: 'Alias',\n            flex: 0.125,\n            sortable: false,\n            menuDisabled: true,\n            dataIndex: 'alias',\n            editor: 'textfield'\n        }, {\n            xtype: 'gridcolumn',\n            text: 'Sort Type',\n            flex: 0.125,\n            sortable: false,\n            menuDisabled: true,\n            dataIndex: 'sorttype'\n        }, {\n            xtype: 'gridcolumn',\n            text: 'Sort Order',\n            flex: 0.125,\n            sortable: false,\n            menuDisabled: true,\n            dataIndex: 'sortorder'\n        }, {\n            xtype: 'checkcolumn',\n            text: 'Grouping',\n            flex: 0.075,\n            sortable: false,\n            menuDisabled: true,\n            dataIndex: 'grouping',\n            align: 'center'\n        }, {\n            xtype: 'gridcolumn',\n            text: 'Criteria',\n            flex: 0.125,\n            sortable: false,\n            menuDisabled: true,\n            dataIndex: 'criteria',\n            editor: 'textfield'\n        }],\n        initComponent: function() {\n            this.callParent(arguments);\n        }\n    });\n\n}());"]],"start1":0,"start2":0,"length1":0,"length2":7368}]],"length":7368}
{"contributors":[],"silentsave":true,"ts":1367457719286,"patch":[[{"diffs":[[0,".SQL"],[-1,"FieldsGrid', {\n        requires: ['Ext.ux.CheckColumn'],\n        extend: 'Ext.grid.Panel',\n        alias: ['widget.sqlfieldsgrid'],\n        id: 'SQLFieldsGrid',\n        store: 'SQLFieldsStore',\n        columnLines: true,\n        plugins: [Ext.create('Ext.grid.plugin.CellEditing', {\n            clicksToEdit: 1\n        })],\n        viewConfig: {\n            listeners: {\n                render: function(view) {\n                    this.dd = {};\n                    this.dd.dropZone = new Ext.grid.ViewDropZone({\n                        view: view,\n                        ddGroup: 'SQLTableGridDDGroup',\n                        handleNodeDrop: function(data, record, position) {\n                            // Was soll nach dem Drop passieren?\n                        }\n                    });\n                },\n                drop: function(node, data, dropRec, dropPosition) {\n                    // add new rows to the SQLFieldsGrid after a drop\n                    for (var i = 0, l = data.records.length; i < l; i++) {\n                        oj.sql.builder.sqlSelect.addFieldRecord(data.records[i], false);\n                    }\n                }\n            }\n        },\n        columns: [{\n            xtype: 'actioncolumn',\n            menuDisabled: true,\n            text: 'Action',\n            width: 60,\n            moveGridRow: function(grid, record, index, direction) {\n                var store = grid.getStore();\n                if (direction < 0) {\n                    index--;\n                    if (index < 0) {\n                        return;\n                    }\n                }\n                else {\n                    index++;\n                    if (index >= grid.getStore().getCount()) {\n                        return;\n                    }\n                }\n                // prepare manual syncing\n                store.suspendAutoSync();\n                // disable firing store events\n                store.suspendEvents();\n                // remove record and insert record at new index\n                store.remove(record);\n                store.insert(index, record);\n                // enable firing store events\n                store.resumeEvents();\n                store.resumeAutoSync();\n                // manual sync the store\n                store.sync();\n            },\n            items: [{\n                icon: 'resources/images/up_arrow.gif',\n                tooltip: 'Move Column Up',\n                getClass: function(value, metadata, record) {\n                    var store, index;\n                    store = record.store;\n                    index = store.indexOf(record);\n                    if (index == 0) {\n                        return 'x-action-icon-disabled';\n                    }\n                    else {\n                        return 'x-grid-center-icon';\n                    }\n                },\n                handler: function(grid, rowIndex, colIndex) {\n                    var rec = grid.getStore().getAt(rowIndex);\n                    this.moveGridRow(grid, rec, rowIndex, - 1);\n                }\n            }, {\n                icon: 'resources/images/down_arrow.gif',\n                getClass: function(value, metadata, record) {\n                    var store, index;\n                    store = record.store;\n                    index = store.indexOf(record);\n                    if ((index + 1) == store.getCount()) {\n                        return 'x-action-icon-disabled';\n                    }\n                    else {\n                        return 'x-grid-center-icon';\n                    }\n                },\n                tooltip: 'Move Column Down',\n                handler: function(grid, rowIndex, colIndex) {\n                    var rec = grid.getStore().getAt(rowIndex);\n                    this.moveGridRow(grid, rec, rowIndex, 1);\n                }\n            }, {\n                icon: 'resources/images/remove.gif',\n                iconCls: 'x-grid-center-icon',\n                tooltip: 'Delete Column',\n                handler: function(grid, rowIndex, colIndex) {\n                    var rec = grid.getStore().getAt(rowIndex),\n                        store, tableId, tableGrid, selectionModel, bDel = true;\n                    // rec contains column grid model, the one to remove\n                    // get tableId of original sqltable\n                    tableId = rec.get('extCmpId');\n                    // get the sql tables grid and its selection\n                    tableGrid = Ext.getCmp(tableId).down('gridpanel');\n                    selectionModel = tableGrid.getSelectionModel();\n                    Ext.Array.each(selectionModel.getSelection(), function(selection) {\n                        // deselect the selection wich corresponds to the column\n                        // we want to remove from the column grid\n                        if (rec.get('id') == selection.get('id')) {\n                            // deselect current selection\n                            // deselection will lead to removal, look for method deselect at the SQLTableGrid\n                            selectionModel.deselect(selection);\n                            bDel = false;\n                        }\n                    });\n                    if (bDel) {\n                        store = grid.getStore();\n                        store.remove(rec);\n                    }\n                }\n            }]\n        }, {\n            xtype: 'checkcolumn',\n            sortable: false,\n            text: 'Output',\n            flex: 0.075,\n            menuDisabled: true,\n            dataIndex: 'output',\n            align: 'center'\n        }, {\n            xtype: 'gridcolumn',\n            text: 'Expression',\n            sortable: false,\n            menuDisabled: true,\n            flex: 0.225,\n            dataIndex: 'expression',\n            editor: 'textfield'\n        }, {\n            xtype: 'gridcolumn',\n            text: 'Aggregate',\n            flex: 0.125,\n            sortable: false,\n            menuDisabled: true,\n            dataIndex: 'aggregate',\n            editor: 'textfield'\n        }, {\n            xtype: 'gridcolumn',\n            text: 'Alias',\n            flex: 0.125,\n            sortable: false,\n            menuDisabled: true,\n            dataIndex: 'alias',\n            editor: 'textfield'\n        }, {\n            xtype: 'gridcolumn',\n            text: 'Sort Type',\n            flex: 0.125,\n            sortable: false,\n            menuDisabled: true,\n            dataIndex: 'sorttype'\n        }, {\n            xtype: 'gridcolumn',\n            text: 'Sort Order',\n            flex: 0.125,\n            sortable: false,\n            menuDisabled: true,\n            dataIndex: 'sortorder'\n        }, {\n            xtype: 'checkcolumn',\n            text: 'Grouping',\n            flex: 0.075,\n            sortable: false,\n            menuDisabled: true,\n            dataIndex: 'grouping',\n            align: 'center'\n        }, {\n            xtype: 'gridcolumn',\n            text: 'Criteria',\n            flex: 0.125,\n            sortable: false,\n            menuDisabled: true,\n            dataIndex: 'criteria',\n            editor: 'textfield'\n        }],\n        initComponent: function() {\n            this.callParent(arguments"],[1,"Table', {\n    extend: 'Ext.window.Window',\n    minWidth: 120,\n    alias: ['widget.sqltable'],\n    cascadeOnFirstShow: 20,\n    height: 180,\n    width: 140,\n    shadowSprite: {},\n    layout: {\n        type: 'fit'\n    },\n    closable: true,\n    listeners: {\n        show: function(){\n            this.initSQLTable();\n        },\n        beforeclose: function(){\n            this.closeSQLTable();\n        }\n    },\n    closeSQLTable: function(){\n        // remove fields / columns from sqlFieldsStore\n        oj.sql.builder.sqlSelect.removeFieldsByTableId(this.tableId);\n\n        // remove table from sqlTables store inside oj.sql.builder.sqlSelect\n        oj.sql.builder.sqlSelect.removeTableById(this.tableId);\n\n        // unregister mousedown event\n        this.getHeader().el.un('mousedown', this.regStartDrag, this);\n        // unregister mousemove event\n        Ext.EventManager.un(document, 'mousemove', this.moveWindow, this);\n        // remove sprite from surface\n        Ext.getCmp('SQLTablePanel').down('draw').surface.remove(this.shadowSprite, false);\n        // remove any connection lines from surface and from array oj.sql.builder.connections\n        oj.sql.builder.connections = Ext.Array.filter(oj.sql.builder.connections, function(connection){\n            var bRemove = true;\n            for (var j = 0, l = this.connectionUUIDs.length; j < l; j++) {\n                if (connection.uuid == this.connectionUUIDs[j]) {\n                    connection.line.remove();\n                    connection.bgLine.remove();\n                    connection.miniLine1.remove();\n                    connection.miniLine2.remove();\n                    bRemove = false;\n                }\n            }\n            return bRemove;\n        }, this);\n\n    },\n    initSQLTable: function(){\n        var sqlTablePanel, xyParentPos, xyChildPos, childSize, sprite;\n\n        // get the main sqlTablePanel\n        sqlTablePanel = Ext.getCmp('SQLTablePanel');\n\n        // get the main sqlTablePanel position\n        xyParentPos = sqlTablePanel.el.getXY();\n\n        // get position of the previously added sqltable\n        xyChildPos = this.el.getXY();\n\n        // get the size of the previously added sqltable\n        childSize = this.el.getSize();\n\n        // create a sprite of type rectangle and set its position and size\n        // to position and size of the the sqltable\n        sprite = Ext.create('Ext.oj-sqlbuilder.SQLTableSprite', {\n            type: 'rect',\n            stroke: '#fff',\n            height: childSize.height - 4,\n            width: childSize.width - 4,\n            x: xyChildPos[0] - xyParentPos[0] + 2,\n            y: xyChildPos[1] - xyParentPos[1] + 2,\n            scrollTop: 0\n        });\n\n        // add the sprite to the surface of the sqlTablePanel\n        this.shadowSprite = sqlTablePanel.down('draw').surface.add(sprite).show(true);\n\n        // handle resizeing of sqltabel\n        this.resizer.on('resize', function(resizer, width, height, event){\n            this.shadowSprite.setAttributes({\n                width: width - 6,\n                height: height - 6\n            }, true);\n            // also move the associated connections\n            for (var i = oj.sql.builder.connections.length; i--;) {\n                this.connection(oj.sql.builder.connections[i]);\n            }\n        }, this);\n\n        // register a function for the mousedown event on the previously added sqltable and bind to this scope\n        this.getHeader().el.on('mousedown', this.regStartDrag, this);\n\n        this.getHeader().el.on('contextmenu', this.showSQLTableCM, this);\n\n        this.getHeader().el.on('dblclick', this.showTableAliasEditForm, this);\n\n        this.getHeader().origValue = '';\n\n        // register method this.moveWindow for the mousemove event on the document and bind to this scope\n        Ext.EventManager.on(document, 'mousemove', this.moveWindow, this);\n\n        // register a function for the mouseup event on the document and add the this scope\n        Ext.EventManager.on(document, 'mouseup', function(){\n            // save the mousedown state\n            this.bMouseDown = false;\n        }, this);\n\n\n    },\n    showSQLTableCM: function(event, el){\n        var cm;\n        // stop the browsers event bubbling\n        event.stopEvent();\n        // create context menu\n        cm = Ext.create('Ext.menu.Menu', {\n            items: [{\n                text: 'Add/Edit Alias',\n                icon: 'resources/images/document_edit16x16.gif',\n                handler: Ext.Function.bind(function(){\n                    this.showTableAliasEditForm();\n                }, this)\n            }, {\n                text: 'Remove Table',\n                icon: 'resources/images/delete.gif',\n                handler: Ext.Function.bind(function(){\n                    // remove the sqltable\n                    this.close();\n                }, this)\n            }, {\n                text: 'Close Menu',\n                icon: 'resources/images/cross.gif',\n                handler: Ext.emptyFn\n            }]\n        });\n        // show the contextmenu next to current mouse position\n        cm.showAt(event.getXY());\n    },\n    showTableAliasEditForm: function(event, el){\n        var table, header, title, titleId;\n        table = oj.sql.builder.sqlSelect.getTableById(this.tableId);\n        header = this.getHeader();\n        titleId = '#' + header.getId() + '_hd';\n        title = this.down(titleId);\n        header.remove(title);\n        header.insert(0, [{\n            xtype: 'textfield',\n            flex: 0.95,\n            parentCmp: header,\n            parentTableModel: table,\n            initComponent: function(){\n\n                this.setValue(this.parentTableModel.get('tableAlias'));\n\n                this.on('render', function(field, event){\n                    // set focus to the textfield Benutzerkennung\n                    field.focus(true, 200);\n                }, this);\n\n                this.on('specialkey', function(field, event){\n                    if (event.getKey() == event.ENTER) {\n                        if (field.getValue() != this.parentCmp.origValue) {\n                            this.parentTableModel.set('tableAlias', field.getValue());\n                            this.parentCmp.origValue = field.getValue();\n                        }\n                        this.removeTextField();\n                        this.addTitle();\n                    }\n                }, this);\n\n                this.on('blur', function(field, event){\n                    if (field.getValue() != this.parentCmp.origValue) {\n                        this.parentTableModel.set('tableAlias', field.getValue());\n                        this.parentCmp.origValue = field.getValue();\n                    }\n                    this.removeTextField();\n                    this.addTitle();\n                }, this);\n\n                this.callParent(arguments);\n            },\n            removeTextField: function(){\n                var next;\n                next = this.next();\n                this.parentCmp.remove(next);\n                this.parentCmp.remove(this);\n            },\n            addTitle: function(){\n                var titleText;\n                if (this.parentTableModel.get('tableAlias') != '') {\n                    titleText = this.parentTableModel.get('tableAlias') + ' ( ' + this.parentTableModel.get('tableName') + ' )';\n                }\n                else {\n                    titleText = this.parentTableModel.get('tableName');\n                }\n                this.parentCmp.insert(0, {\n                    xtype: 'component',\n                    ariaRole: 'heading',\n                    focusable: false,\n                    noWrap: true,\n                    flex: 1,\n                    id: this.parentCmp.id + '_hd',\n                    style: 'text-align:' + this.parentCmp.titleAlign,\n                    cls: this.parentCmp.baseCls + '-text-container',\n                    renderTpl: this.parentCmp.getTpl('headingTpl'),\n                    renderData: {\n                        title: titleText,\n                        cls: this.parentCmp.baseCls,\n                        ui: this.parentCmp.ui\n                    },\n                    childEls: ['textEl']\n                });\n            }\n        }, {\n            xtype: 'component',\n            flex: 0.05\n        }]);\n    },\n    regStartDrag: function(){\n        // save the mousedown state\n        this.bMouseDown = true;\n        // start the drag of the sprite\n        this.shadowSprite.startDrag(this.getId());\n    },\n    moveWindow: function(event, domEl, opt){\n        var relPosMovement;\n        // check mousedown\n        if (this.bMouseDown) {\n            // get relative x and y values (offset)\n            relPosMovement = this.getOffset('point');\n            // move the sprite to the position of the window\n            this.shadowSprite.onDrag(relPosMovement);\n            // check if the sprite has any connections\n            if (this.shadowSprite.bConnections) {\n                // also move the associated connections\n                for (var i = oj.sql.builder.connections.length; i--;) {\n                    this.connection(oj.sql.builder.connections[i]);\n                }\n            }\n        }\n    },\n    getLeftRightCoordinates: function(obj1, obj2, aBBPos){\n        var bb1, bb2, p = [], dx, leftBoxConnectionPoint, rightBoxConnectionPoint, dis, columHeight = 21, headerHeight = 46, LeftRightCoordinates = {};\n\n        // BoundingBox Koordinaten für beide Sprites abrufen\n\n        bb1 = obj1.getBBox();\n        // y Wert für connection Points auf der linken und rechten Seite von bb1\n        bb1.pY = bb1.y + headerHeight + ((aBBPos[0] - 1) * columHeight) + (columHeight / 2) - obj1.scrollTop;\n\n        bb2 = obj2.getBBox();\n        // y Wert für connection Points auf der linken und rechten Seite von bb2\n        bb2.pY = bb2.y + headerHeight + ((aBBPos[1] - 1) * columHeight) + (columHeight / 2) - obj2.scrollTop;\n\n        // code für linke boundingBox\n        if (bb1.pY > (bb1.y + 4) && bb1.pY < (bb1.y + bb1.height - 4)) {\n            p.push({\n                x: bb1.x - 1, // Punkt auf linker Seite auf Höhe der verknüpften Spalte\n                y: bb1.pY\n            });\n            p.push({\n                x: bb1.x + bb1.width + 1, // Punkt auf rechter Seite auf Höhe der verknüpften Spalte\n                y: bb1.pY\n            });\n        }\n        else {\n            if (bb1.pY < (bb1.y + 4)) {\n                p.push({\n                    x: bb1.x - 1, // Punkt auf linker Seite max. obere Position\n                    y: bb1.y + 4\n                });\n                p.push({\n                    x: bb1.x + bb1.width + 1, // Punkt auf rechter Seite max. obere Position\n                    y: bb1.y + 4\n                });\n            }\n            else {\n                p.push({\n                    x: bb1.x - 1, // Punkt auf linker Seite max. untere Position\n                    y: bb1.y + bb1.height - 4\n                });\n                p.push({\n                    x: bb1.x + bb1.width + 1, // Punkt auf rechter Seite max. untere Position\n                    y: bb1.y + bb1.height - 4\n                });\n            };\n                    };\n\n        //  code für rechte boundingBox\n        if (bb2.pY > (bb2.y + 4) && bb2.pY < (bb2.y + bb2.height - 4)) {\n            p.push({\n                x: bb2.x - 1, // Punkt auf linker Seite auf Höhe der verknüpften Spalte\n                y: bb2.pY\n            });\n            p.push({\n                x: bb2.x + bb2.width + 1, // Punkt auf rechter Seite auf Höhe der verknüpften Spalte\n                y: bb2.pY\n            });\n        }\n        else {\n            if (bb2.pY < (bb2.y + 4)) {\n                p.push({\n                    x: bb2.x - 1, // Punkt auf linker Seite max. obere Position\n                    y: bb2.y + 4\n                });\n                p.push({\n                    x: bb2.x + bb2.width + 1, // Punkt auf rechter Seite max. obere Position\n                    y: bb2.y + 4\n                });\n            }\n            else {\n                p.push({\n                    x: bb2.x - 1, // Punkt auf linker Seite max. untere Position\n                    y: bb2.y + bb2.height - 4\n                });\n\n                p.push({\n                    x: bb2.x + bb2.width + 1, // Punkt auf rechter Seite max. untere Position\n                    y: bb2.y + bb2.height - 4\n                });\n            }\n        };\n\n        // Schleife über die Punkte der ersten BoundingBox\n        for (var i = 0; i < 2; i++) {\n            // Schleife über die Punkte der zweiten BoundingBox\n            for (var j = 2; j < 4; j++) {\n                // Berechnung der Offsets zwischen den jeweils vier Punkten beider BoundingBoxes\n                dx = Math.abs(p[i].x - p[j].x), dy = Math.abs(p[i].y - p[j].y);\n                // bb1 links mit bb2 rechts\n                if (((i == 0 && j == 3) && dx < Math.abs(p[1].x - p[2].x)) || ((i == 1 && j == 2) && dx < Math.abs(p[0].x - p[3].x))) {\n                    leftBoxConnectionPoint = p[i];\n                    rightBoxConnectionPoint = p[j];\n                }\n            }\n        };\n\n        return {\n            leftBoxConnectionPoint: leftBoxConnectionPoint,\n            rightBoxConnectionPoint: rightBoxConnectionPoint\n        };\n\n    },\n    connection: function(obj1, obj2, line, aBBPos){\n        var LeftRightCoordinates, line1, line2, miniLine1, miniLine2, path, surface, color = typeof line == \"string\" ? line : \"#000\";\n\n        if (obj1.line && obj1.from && obj1.to && obj1.aBBPos) {\n            line = obj1;\n            obj1 = line.from;\n            obj2 = line.to;\n            aBBPos = line.aBBPos;\n        }\n\n        // set reference to the wright surface\n        surface = obj1.surface;\n\n        // get coordinates for the left and right box\n        LeftRightCoordinates = this.getLeftRightCoordinates(obj1, obj2, aBBPos);\n\n        // check if the LeftBox is still on the left side or not\n        if (LeftRightCoordinates.leftBoxConnectionPoint.x - LeftRightCoordinates.rightBoxConnectionPoint.x < 0) {\n            line1 = 12;\n            line2 = 12;\n        }\n        else {\n            line1 = -12;\n            line2 = -12;\n        }\n        // define the path between the left and the right box\n        path = [\"M\", LeftRightCoordinates.leftBoxConnectionPoint.x, LeftRightCoordinates.leftBoxConnectionPoint.y, \"H\", LeftRightCoordinates.leftBoxConnectionPoint.x + line1, \"L\", LeftRightCoordinates.rightBoxConnectionPoint.x - line2, LeftRightCoordinates.rightBoxConnectionPoint.y, \"H\", LeftRightCoordinates.rightBoxConnectionPoint.x].join(\",\");\n\n        miniLine1 = [\"M\", LeftRightCoordinates.leftBoxConnectionPoint.x, LeftRightCoordinates.leftBoxConnectionPoint.y, \"H\", LeftRightCoordinates.leftBoxConnectionPoint.x + line1].join(\",\");\n\n        miniLine2 = [\"M\", LeftRightCoordinates.rightBoxConnectionPoint.x - line2, LeftRightCoordinates.rightBoxConnectionPoint.y, \"H\", LeftRightCoordinates.rightBoxConnectionPoint.x].join(\",\");\n\n        //check if it is a new connection or not\n        if (line && line.line) {\n            // old connection, only change path\n            line.bgLine &&\n            line.bgLine.setAttributes({\n                path: path\n            }, true);\n            line.line.setAttributes({\n                path: path\n            }, true);\n            line.miniLine1.setAttributes({\n                path: miniLine1\n            }, true);\n            line.miniLine2.setAttributes({\n                path: miniLine2\n            }, true);\n        }\n        else {\n            // new connction, return new connection object\n            return {\n                line: Ext.create('Ext.draw.Sprite', {\n                    type: 'path',\n                    path: path,\n                    stroke: color,\n                    fill: 'none',\n                    'stroke-width': 1,\n                    surface: surface\n                }).show(true),\n                miniLine1: Ext.create('Ext.draw.Sprite', {\n                    type: 'path',\n                    path: miniLine1,\n                    stroke: color,\n                    fill: 'none',\n                    'stroke-width': 2,\n                    surface: surface\n                }).show(true),\n                miniLine2: Ext.create('Ext.draw.Sprite', {\n                    type: 'path',\n                    path: miniLine2,\n                    stroke: color,\n                    fill: 'none',\n                    'stroke-width': 2,\n                    surface: surface\n                }).show(true),\n                bgLine: Ext.create('Ext.draw.Sprite', {\n                    type: 'path',\n                    path: path,\n                    opacity: 0,\n                    stroke: '#fff',\n                    fill: 'none',\n                    'stroke-width': 10,\n                    surface: surface\n                }).show(true),\n                from: obj1,\n                to: obj2,\n                aBBPos: aBBPos,\n                uuid: this.createUUID()\n            };\n        }\n    },\n    initComponent: function(){\n        var store, tableModel;\n\n        this.connectionUUIDs = [];\n        this.bMouseDown = false;\n\n        // asign a uuid to the window, this builds relationship with sqlTable\n        this.tableId = this.createUUID();\n\n\n        store = Ext.create('Ext.data.Store', {\n            autoLoad: true,\n            fields: [{\n                name: 'id',\n                type: 'string'\n            }, {\n                name: 'tableName',\n                type: 'string'\n            }, {\n                name: 'tableId',\n                type: 'string',\n                defaultValue: this.tableId\n            }, {\n                name: 'field',\n                type: 'string'\n            }, {\n                name: 'extCmpId',\n                type: 'string',\n                defaultValue: this.id\n            }, {\n                name: 'type',\n                type: 'string'\n            }, {\n                name: 'null',\n                type: 'string'\n            }, {\n                name: 'key',\n                type: 'string'\n            }, {\n                name: 'default',\n                type: 'string'\n            }, {\n                name: 'extra',\n                type: 'string'\n            }],\n            proxy: {\n                type: 'memory',\n                reader: {\n                    type: 'json',\n                    root: 'items'\n                }\n            },\n            data: { items: [{ \"field\": \"*\", \"extra\": \"\", \"id\": \"D04A39CB-AF22-A5F3-0246BA11FD51BCD8\", \"key\": \"\", \"tableName\": \"bestellung\", \"null\": \"\", \"default\": \"\", \"type\": \"\" }, { \"field\": \"bestell_id\", \"extra\": \"auto_increment\", \"id\": \"D04A39CC-E436-C0BE-1D51AEF07A7A5AAF\", \"key\": \"PRI\", \"tableName\": \"bestellung\", \"null\": false, \"default\": \"\", \"type\": \"int(11)\" }, { \"field\": \"bestell_datum\", \"extra\": \"\", \"id\": \"D04A39CD-E13A-7228-81930472A5FC49AE\", \"key\": \"\", \"tableName\": \"bestellung\", \"null\": true, \"default\": \"\", \"type\": \"datetime\" }, { \"field\": \"bname\", \"extra\": \"\", \"id\": \"D04A39CE-04F3-D1CE-A1D72B04F40920C2\", \"key\": \"MUL\", \"tableName\": \"bestellung\", \"null\": true, \"default\": \"\", \"type\": \"varchar(255)\" }] }\n        });\n\n        // add sql table to oj.sql.builder.sqlSelect tables store\n        // also asign same id as stores uuid\n        tableModel = Ext.create('Ext.oj-sqlbuilder.SQLTableModel', {\n            id: this.tableId,\n            tableName: this.title,\n            tableAlias: ''\n        });\n        oj.sql.builder.sqlSelect.addTable(tableModel);\n\n        this.items = [{\n            xtype: 'sqltablegrid',\n            store: store\n        }];\n\n        this.callParent(arguments);\n    },\n    getOffset: function(constrain){\n        var xy = this.dd.getXY(constrain), s = this.dd.startXY;\n        // return the the difference between the current and the drag&drop start position\n        return [xy[0] - s[0], xy[1] - s[1]];\n    },\n    createUUID: function(){\n        // http://www.ietf.org/rfc/rfc4122.txt\n        var s = [];\n        var hexDigits = \"0123456789abcdef\";\n        for (var i = 0; i < 36; i++) {\n            s[i] = hexDigits.substr(Math.floor(Math.random() * 0x10), 1);\n        }\n        s[14] = \"4\"; // bits 12-15 of the time_hi_and_version field to 0010\n        s[19] = hexDigits.substr((s[19] & 0x3) | 0x8, 1); // bits 6-7 of the clock_seq_hi_and_reserved to 01\n        s[8] = s[13] = s[18] = s[23] = \"-\";\n\n        var uuid = s.join(\"\");\n        return uuid;\n    },\n    beforeShow: function(){\n        var aWin, prev, o;\n        // cascading window positions\n        if (this.cascadeOnFirstShow) {\n            o = (typeof this.cascadeOnFirstShow == 'number') ? this.cascadeOnFirstShow : 20;\n            // get all instances from xtype sqltable\n            aWin = Ext.ComponentQuery.query('sqltable');\n            // start position if there is only one table\n            if (aWin.length == 1) {\n                this.x = o;\n                this.y = o;\n            }\n            else {\n                // loop through all instances from xtype sqltable\n                for (var i = 0, l = aWin.length; i < l; i++) {\n                    if (aWin[i] == this) {\n                        if (prev) {\n                            this.x = prev.x + o;\n                            this.y = prev.y + o;\n                        }\n                    }\n                    if (aWin[i].isVisible()) {\n                        prev = aWin[i];\n                    }\n                }\n            }\n            this.setPosition(this.x, this.y"],[0,");\n "]],"start1":84,"start2":84,"length1":7261,"length2":21520},{"diffs":[[0,"      }\n    "],[-1,""],[0,""],[1,"}\n"],[0,"});\n\n}());"]],"start1":21605,"start2":21605,"length1":22,"length2":24}]],"length":21629,"saved":false}
{"contributors":[],"silentsave":true,"ts":1368235032742,"patch":[[{"diffs":[[0,"  uuid: "],[-1,"this"],[1,"OJ"],[0,".createU"]],"start1":17072,"start2":17072,"length1":20,"length2":18},{"diffs":[[0,"ableName\": \""],[-1,"bestellung"],[1,"library"],[0,"\", \"null\": \""]],"start1":18651,"start2":18651,"length1":34,"length2":31},{"diffs":[[0,"ield\": \""],[-1,"bestell_"],[1,"library"],[0,"id\", \"ex"]],"start1":18718,"start2":18718,"length1":24,"length2":23},{"diffs":[[0,"ableName\": \""],[-1,"bestellung"],[1,"library"],[0,"\", \"null\": f"]],"start1":18826,"start2":18826,"length1":34,"length2":31},{"diffs":[[0,"\": \""],[-1,"bestell_datum"],[1,"opened"],[0,"\", \""]],"start1":18907,"start2":18907,"length1":21,"length2":14},{"diffs":[[0,"ableName\": \""],[-1,"bestellung"],[1,"library"],[0,"\", \"null\": t"]],"start1":18991,"start2":18991,"length1":34,"length2":31},{"diffs":[[0,"ield\": \""],[-1,"b"],[0,"name\", \""]],"start1":19068,"start2":19068,"length1":17,"length2":16},{"diffs":[[0,"\": \""],[-1,"bestellung"],[1,"library"],[0,"\", \""]],"start1":19165,"start2":19165,"length1":18,"length2":15}]],"length":21606,"saved":false}
